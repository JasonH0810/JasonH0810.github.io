---
title: '[Studying record] Web Security'
date: 2023-12-04
permalink: /posts/2023/12/SR_Web Security/
tags:
  - Web Security
  - Studying Record
---
Some records and thinking about the book - 白帽子讲Web安全

# 1.浏览器安全


## 1.1 同源策略

同源策略（Same Origin Policy）是浏览器最核心也是最基本的安全功能。**浏览器的同源策略，限制了来自不同源的“Document”或脚本，对当前“Document”读取或者设置某些属性。**

在JavaScript中影响源的因素有：host（域名或IP，如果是IP则看做一个根域名），子域名，端口，协议（如http与https）

对于当前页面，JS文件存放的位置不重要，加载JS文件所在的域更重要。例如a.com加载了b.com下的b.js，此时对于当前打开页面，b.js的origin是a.com而不是b.com。

对于<script>,<img>,<iframe>,<link>等标签都可以跨域加载资源，这些标签每次加载时，实际上相当于浏览器发起了一次GET请求，同时浏览器鞋质量JS的权限，使其不能读，写返回的内容。

## 1.2 浏览器沙箱

为了防止网页被插入恶意代码，浏览器采用多进程架构，将各个功能模块以及各个浏览器实例分开，当一个进程崩溃是也不会影响到其他进程。Chrome第一个采用多进程架构，主要分为：浏览器进程，渲染进程，插件进程，扩展进程。

Sandbox泛指“资源隔离类模块”，目的是为了让不信任的代码在一定环境下运行，限制不可信的代码访问隔离区之外的资源。跨越Sandbox边界的资源交互只能通过指定的数据通道，例如API，这些API会严格检查请求的合法性。


## 1.3 恶意网址拦截

常见的恶意网址分为两类：
- 挂马网站：在这类网站上通常会有一些恶意的脚本，试图通过利用浏览器的漏洞执行shellcode，在用户机器上植入木马。
- 钓鱼网站：这类网站通过模仿一些知名网站欺骗用户输入敏感信息等。

恶意网站拦截的工作原理一般是浏览器周期性地从服务端获取一份最新的恶意网址黑名单，如果用户访问则会弹出警告。同时，主流浏览器也支持Extended Validation SSL Certificate。


# 2.跨站脚本攻击（XSS）

## 2.1 XSS简介

Cross Site Script（XSS）攻击通常只黑客通过“HTML注入”篡改网页，插入了恶意的脚本，从而在用户浏览网页时控制浏览器的一种攻击。

XSS攻击类型：
- 反射型XSS（Non-persistent XSS）：这类攻击只是简单地把用户的输入反射给浏览器，黑客只需要诱导用户点击设计好的恶意链接，才能攻击成功。
- 存储型XSS（Persistent XSS）：这类攻击常见的场景时攻击者将存在恶意注入代码的文件或是数据已上传的方式存储到服务端，当有正常用户访问该文件或者数据时，都会在他们的浏览器执行这段恶意代码。

## 2.2 XSS构造技巧
- 利用字符编码：利用Unicode编码和GBK/GB232的编码差异，对一些过滤字符进行闭合。
- 绕过长度限制： 可以利用不同的代码写法进行XSS攻击，但最好的方法是是将恶意攻击代码写到别处，使用代码加载恶意攻击代码。Example：将代码写在“location.hash”中。也可以利用注释符绕过长度限制。 
- 使用<base>标签：通过在远程服务器伪造图片，链接或脚本，劫持当前页面中的所有使用“相对路径”的标签。
- Window.name：使用window.name对象，攻击者可以实现跨域，跨页面传递数据。
一些有用的绕过技巧[Link](htp://secinn.appspot.com/pstzine/read?issue=3&articleid=4)

## 2.3 XSS防御
- HttpOnly：该策略有微软提出。浏览器禁止页面的JS访问带有HttpOnly属性的cookie。这一防御策略严格来说是为了防御XSS攻击之后的cookie劫持。
- 输入检查：对于一些常见的web漏洞，攻击者都需要使用一些特殊字符进行payload的构造，但这些字符通常不会被用户所使用。采用白名单的方式，对用户的输入进行过滤，可以起到一定的缓解作用。但是XSS filter无法对语境进行完整的理解，因此不恰当的设置可能会导致一些错误过滤。
- 输出检查：在变量输出到html页面时，可以使用编码或者转义的方式来防御XSS攻击。例如使用HtmlEncode对Html代码进行编码，对JS使用javascriptencode。

# 3.跨站点请求伪造（CSRF）

## 3.1 CSRF介绍

攻击者通过引诱用户点击其精心构造的链接进行攻击

## 3.2 浏览器cookie策略

通常来说浏览器的cookie分为两种：Session cookie 和Third-party cookie。两者的区别在于Third-party cookie是服务器在set-cookie时指定了cookie的Expire时间，这种cookie保存在本地，到了Expire时间后失效。
Session cookie没有指定时间，在浏览器关闭之后失效，Session cookie保存在浏览器进程的内存空间中。

部分浏览器会在加载另一个域的资源时阻止third-party cookie的发送。而成功的发送可能会导致CSRF攻击成功。

## 3.3 P3P Header
P3P Header（The Platform for Privacy Preferences）是W3C制定的一项隐私标准。如果网站返回给浏览器的http头中含有P3P头，则有可能允许浏览器向第三方发送cookie

## 3.4 CSRF 防御

- 验证码：使用验证码强制用户与应用进行交互。但是验证码会影响用户体验，所以不能作为主要的防御手段
- Referer Check： 常见的互联网应用，页面与页面之间有一定的逻辑关系，这就是的每个正常请求的referer具有一定规律。Referer check可以被用于检查请求是否来自合法的源。Referer Check的缺陷在于，服务器并非什么时候都能娶到Referer。
- Anti CSRF Token： 使用一定的安全加密算法生成一个token并加入到session或cookie中，提交请求时，服务器会验证表单中的Token。

# 4.点击劫持（clickjacking）

## 4.1 点击劫持介绍
点击劫持是一种视觉上的欺骗手段，攻击者通过一个透明的不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以又是用户恰好点击在iframe页面的一些功能性按钮上。


# 5.HTML5安全


# 6.注入攻击

注入攻击的本质是把用户输入的数据当作代码执行。两个关键条件：用户能够控制输入，原本成需要执行的代码拼接了用户输入的数据。

## 6.1 SQL注入介绍
通过拼接sql查询语句到用户输入中注入sql代码进行查询。如果Web服务器开启了错误回显，则可通过错误回显获取敏感信息。

- Blind Injection：当Web服务器关闭错误回显时，可以构造简单语句，根据返回页面是否发生变化来判断SQl注入是否执行。
- Timing Injection： 利用Benchmark（）等函数，让同一个函数执行若干次，使得结果返回的时间比平时要长。通过时间长短的变化判断注入语句是否执行成功。
- 编码问题：利用Unicode和GBK的编码方式不同进行注入攻击
- SQL Column Truncation：没开启STRICT_ALL_TABLES选项时，MySQL对于用户插入的超长值只会提示warning，而不是error，这可能导致发生一些“截断”问题。例如WordPress的案例，新注册一个“admin+（55个空格）”的用户，就可以修改原管理员的密码。

## 6.2 正确地防御SQL

- 使用预编译语句：一般防御SQL注入的最佳方式，就是使用预编译语句，绑定变量。
- 使用存储过程： 使用存储过程的效果和使用预编译语句类似，其区别是存储过程需要先将SQL语句定义在数据库中，但注意存储过程中也可能会存在注入问题，应当尽量避免使用动态的SQL语句。如果无法避免则应该使用严格的输入过滤或者是编码函数来处理用户的输入数据
- 检查数据类型： 对于输入限制输入的数据类型
- 使用安全的函数，同时对于数据库而言，使用最小权限原则，避免web直接使用root等高权限账户。

## 6.3 其他注入攻击

- XML攻击：和HTML一样，注入的方式与修补的方式也很像
- 代码注入：代码注入通常是使用了一些不安全的函数，例如eval()函数。此外JSP的动态include也会导致代码注入。预防方式是避免使用不安全的函数。
- CRLF注入（Carriage return（\r）&Line feed(\n)）：由于CRLF常被使用做不同语义之间的分隔符，因此注入CRLF字符有可能改变原有语义

# 7.文件上传漏洞

文件上传漏洞通常来说是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。要完成文件上传漏洞攻击需要满足的几个条件：上传的文件能被Web容器解释执行，用户能够从Web上访问这个文件，用户上传的文件不能安全检查，格式化，图片压缩等功能改变内容。

## 7.1 绕过文件上传检查

- 很多情况下很多应用会通过判断文件名后缀的方法验证，因此可以手动修改上传过程中的POST包，在文件名后添加一个%00字节来截断某些函数对于文件名的判断。
- 还可以通过伪造文件头的方式绕过一些检查

## 7.2 一些常见问题

- Apache文件解析问题：Apache的文件名解析是从后往前解析，知道遇见认识的文件类型。所以a.php.rar.rar会被认作一个合法的上传文件，但是在Apache解析的过程中会认作一个php文件
- IID文件间隙问题：可以通过“；”截断文件名。
- PHP CGI路径解析问题： Nginx配置fastcgi使用php时，会将上传的图片当作php解析，并执行图片内容，如果图片内容是PHP文件，则会导致代码执行。

## 7.3 设计安全的文件上传功能

- 文件上传目录设置为不可执行
- 判断文件类型，使用MINE TYPE等多种方式检查，使用白名单的方式。对于图片处理采用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码
- 使用随机数改写文件名和文件路径
- 单独设置文件服务器的域名


# 8.应用层拒绝服务攻击

## 8.1 DDOS简介

DDOS（Distributed Denial of Service）是利用合理的请求造成资源过载，从而导致服务不可用。常见的DDOS攻击有SYN flood，UDP flood，ICMP flood等。以SYN flood为例，攻击者会伪造大量源IP地址向目标服务器发送大量的TCP握手请求。因为伪造的IP并不会应答，因此服务器在没有收到伪造的IP回应时，会重试发送并等待一个SYN time。在收到大量发送时这种半连接会消耗大量的CPU和内存资源。

## 8.2 应用层拒绝服务攻击

- cc攻击：cc攻击的远离是对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。
- slowloris攻击：slowloris攻击的原理是以极低的速度往服务器发送HTTP请求。由于Web server对于并发的连接数有上限，因此恶意占用会导致无法接受新的请求。
- HTTP POST DOS：其原理是在发送HTTP POST包时指定一个非常大的content-lenth，然后以极低的速度发包。和slowloris类似，以这种方式占用连接数导致拒绝服务。
- Server Limit DOS：这是一种利用cookie的拒绝服务攻击，其原理是恶意地往客户端写入一个超长的cookie，则该客户端在清空cookie之前无法再访问cookie所在域的任何页面。

# 9.PHP安全

## 9.1 文件包含漏洞

文件包含漏洞本身属于代码注入的一种，其原理是注入一段用户能控制的脚本或代码，并让服务器端执行。常见导致文件包含漏洞的函数有： include(),include_once(),require()等，这些函数会将包含文件当做一个php文件执行，php内核并不会在意该文件是什么类型。
- 本地文件包含：能够打开并包含本地文件的漏洞被称为本地文件包含漏洞。
- 远程文件包含： 如果PHP的配置选项allow_url_include为ON的话，则include等函数可以加载远程文件，这种漏洞被称为远程包含漏洞

## 9.2 变量覆盖漏洞

- 全局变量覆盖：变量如果未被初始化，且能被用户控制，则很有可能会导致安全问题尤其是在register_globals为ON时。
- extract()变量覆盖： 当extract函数从用户可以控制的数组中导出变量时，可能发生变量覆盖。
- 遍历初始化变量：常见的一些以遍历的方式释放变量的代码，可能会导致变量覆盖
- import_request_variables变量覆盖
- parse_str变量覆盖

## 9.3 代码执行漏洞


